\chapter{Requirement Analysis}

\section{Purpose}
\par
The purpose of this system is to build a configuration management and monitoring
system that is dead simple to use. Highly efficient and feature rich
configuration management systems such as Ansible exists. But the problem is that
they have very steep learning curve. This is also the case with monitoring
systems such as Nagios which require considerable amount of setup from the part
of admins. \\

The learning curve makes these systems unsuitable to small office environments,
schools or colleges where the systems are managed by regular employees. NetDog
is dead simple, with zero learning curve. As long as a person is aware of the
command he/she wishes to execute on the remote machine, the person is ready to
use NetDog. \\

\section{Overall Description}
\par
NetDog has a client server architecture. The server is responsible for issuing
commands to the clients and is to be used by the administrator of the network.
The client application is to be run on machines on the network to be
administered.

After installing NetDog server or client on a machine, a unique public-private
key pair for the machine is generated which is then used for uniquely
identifying the machine and securing data transmission between the client and
server.

Once the server program is up and running, it listens on the port 1337 for
connections from clients. Once the client program is up, it starts listening on
port 1994. These ports serve dual purpose of facilitating communication and
allowing the identification of server and clients from the rest of the machines
on the network. Both NetDog server and client are daemons. They are system 
services which remain in memory and automatically starts during system boot.

When a client starts for the first time, it looks for active servers on the
network. When it finds one, it starts the pairing procedure. During the pairing
process, the client sends its hostname and public-key. The server in turn
provides the client with it's public key. These keys are then used for
identification and encrypted communication between machines.

The client and server uses public key encryption to identify and secure the
communication between them. The network admininstrator can issue commands from
the server machine which will then be sent to all the clients on the network.
A client can also contact the server occasionally, for example if the client
detects undseriable network traffic or if the system is overheating.

NetDog is capable of shutting down all the clients on the network at once by
remotely executing the shutdown command. It is also able to power up systems
which support remote Wake-On-LAN feature, by sending magic packets.

\subsection{Product Functions}
The main functions of the proposed product includes \\

\begin{itemize}
\item Bring all computers on the network up and down remotely
\item Execute commands/scripts remotely on machines
\item Copy files to remote machines without third party protocols
\item Track and identify clients through IP changes
\item Secure client-server communication using public key encryption
\item List all machines on the network which are not clients (detect intruders)
\item Centralized logging of all data regarding clients
\item Web interface
\end{itemize}

\subsection{Operating Environment}
The operating environment required are: \\
\begin{itemize}
\\
\item\textbf{ Hardware Requirements} \\ \\
Processor			:	Intel i3\\
Storage				: 	5 GB hard disk space\\
Memory				: 	8 GB RAM\\ 
\\
\item\textbf{Software Requirements} \\ \\
Operating system	: 	Linux\\
Database			: 	MySQL\\
Frameworks			: 	Python,c++,java,php,cmake\\
Server				: 	Apache2\\ \\ \\
\end{itemize}
\section{Functional requirements}  \\
\\
Functional requirements represent the intended behavior of the system. This behavior may be expressed as services, tasks or functions that the specified system is required to perform. The following functional requirements have been identified for this project.
The proposed system consists of 3 modules. They are given below: \\ \\
\begin{itemize}
\item \textbf{ANDROID APPLICATION}\\ \\
In order to make the proposed system user friendly, an android application is used to collect the user details. Users can register through the app, can enter details of their journey including source, destination and the route they are going through. From the details stored in the RTA server, they will get an update about the traffic conditions and vehicle count through the android application. \\ \\
\item \textbf{OpenCV APPLICATION FOR VEHICLE DETECTION AND COUNTING}\\ \\
An Automatic vehicle detecting and counting system makes use of video data acquired from stationary traffic cameras, performing causal mathematical operations over a set of frames obtained from the video to estimate the number of vehicles present in a scene. It is just the ability of automatically extract and recognize the traffic data e.g. total number of vehicles, vehicle number and label from a video. In each video frame, Pixel Based Adaptive Segmenter differentiates objects in motion from the background by tracking detected objects inside a specific region of the frame, and then counting is carried out. In this system, blob detection uses contrast in a binary image to compute a detected region, itâ€™s centroid, and the area of the blob. The supplied pixels detected the foreground. These pixels are grouped, in current frame, together by utilizing a contour detection algorithm. The contour detection algorithm groups the individual pixels into disconnected classes, and then finds the contours surrounding each class. \\
Each class is marked as a candidate blob (CB). These CB are then checked by their size and small blobs are removed from the algorithm to reduce false detections. The positions of the CB, in current frame, are compared using the k-Means clustering that finds the centers of clusters and groups the input samples CB around the clusters to identify the vehicles in each region. The moving vehicle is counted when it passes the base line. When the vehicle passes through that area, the frame is recorded. In each region the blob with the same label are analyzed and the vehicle count is incremented.\\ \\
\item \textbf{Real-time Traffic Analyzer SERVER}\\ \\
OpenCV application detects and counts the vehicle and the server gets updated with this count in every 15 minutes. Counting vehicles gives us the information needed to obtain a basic understanding over the flow of traffic in any region under surveillance. The total count of vehicles, including other traffic details such as source and destination of user are stored on the server. This will help to make a traffic analysis. The RTA server will notify the user in real time.\\ \\

\end{itemize}
\section{Non Functional requirements}
\\ \\
\par Non-Functional requirements define the general qualities of the software product. Non-functional requirement is in effect a constraint placed on the system or the development process. They are usually associated with the product descriptions such as maintainability, usability, portability, etc. it mainly limits the solutions for the problem. The solution should be good enough to meet the non-functional requirements.\\ 
\\
\textbf{Performance Requirements}\\
\begin{itemize}
\item Accuracy: Accuracy in functioning and the nature of user-friendliness should be
maintained in the system.\\
\item Speed: The system must be capable of offering speed.\\
\end{itemize}
\newpage
\textbf{Quality Requirements}
\begin{itemize}
\item Scalability: The software will meet all of the functional requirements. \\
\item Maintainability: The system should be maintainable. It should keep backups to atone for system failures, and should log its activities periodically. \\
\item Reliability: The acceptable threshold for down-time should be long as possible. i.e.mean time between failures should be large as possible. And if the system is broken,
time required to get the system back up again should be minimum. \\
\end{itemize}
